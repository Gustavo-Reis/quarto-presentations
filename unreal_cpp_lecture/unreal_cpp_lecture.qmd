---
title: "C++ Programming in Unreal Engine"
subtitle: "Unreal Authorized Instructor"
author: "Gustavo Reis"
date: today
format:
  revealjs:
    theme: dark
    slide-number: true
    chalkboard: true
    preview-links: auto
    logo: ""
    footer: "Unreal Authorized Instructor - C++ in Unreal"
    transition: slide
    background-transition: fade
    highlight-style: github
    code-line-numbers: true
    width: 1600
    height: 900
    scrollable: true
---

<style>
.reveal pre {
    width: 98%;
    margin: auto;
    font-size: 0.7em;
    line-height: 1.1;
}
.reveal code {
    max-width: none;
    overflow-x: auto;
}
.reveal table {
    font-size: 0.75em;
    margin: auto;
    width: 95%;
}
</style>

# C++ in Unreal Engine {background-color="#0f1419"}

## Learning Objectives

By the end of this session, you will:

- Understand when to use C++ vs Blueprints
- Know the professional C++ → Blueprint workflow
- Create and compile your first C++ Actor class
- Implement basic collision and events

::: {.notes}
30-minute tight schedule. Focus on core concepts and practical workflow.
:::


# Why C++ in Unreal? {background-color="#0f1419"}

## The Performance Advantage

- **Native Speed**: C++ compiles to machine code
- **Memory Control**: Direct memory management
- **Full Engine Access**: Complete Unreal API available

## When to Choose C++
- Performance-critical systems (AI, physics calculations)
- Complex algorithms and data structures
- Foundation systems that multiple assets will use

::: {.notes}
Keep this brief - focus on the key decision points for when C++ is necessary.
:::


# The Professional Workflow {background-color="#0f1419"}

## Industry Standard: C++ Base + Blueprint Child

**Core Principle**: All gameplay logic in C++, all visual assets in Blueprint children.

```cpp
UCLASS(BlueprintType, Blueprintable)  // Key: Make it Blueprintable!
class MYGAME_API ACollectible : public AActor
{
    GENERATED_BODY()
    
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Collectible")
    int32 PointValue = 10;
    
    UFUNCTION(BlueprintImplementableEvent)
    void OnCollectedEffects();  // Blueprint handles visual/audio
};
```

## The Workflow:
1. **Write C++ class** with all gameplay logic
2. **Create Blueprint child** that inherits from C++ class
3. **Add meshes, particles, sounds** in Blueprint
4. **Never place C++ class in level** - always place Blueprint child

::: {.notes}
This is the most important concept - spend time here. One C++ class, multiple Blueprint variants.
:::


# Essential C++ Macros {background-color="#0f1419"}

## The Big Four

```cpp
UCLASS(BlueprintType, Blueprintable)
class MYGAME_API ACollectible : public AActor
{
    GENERATED_BODY()
    
public:
    UPROPERTY(EditAnywhere, BlueprintReadWrite)
    float Health = 100.0f;
    
    UFUNCTION(BlueprintCallable)
    void TakeDamage(float Amount);
};
```

- **UCLASS()**: Exposes class to Unreal's reflection system
- **UPROPERTY()**: Makes variables visible to editor/Blueprints
- **UFUNCTION()**: Exposes functions to Blueprints
- **GENERATED_BODY()**: Required boilerplate

::: {.notes}
These four macros are fundamental - everything else builds on these.
:::


# Creating Your First C++ Actor {background-color="#0f1419"}

## Quick Setup

### Step 1: Generate Class
1. **Add New → C++ Class**
2. Choose **Actor** parent
3. Name: `Collectible`
4. **Create Class**

### Step 2: Live Coding Workflow
1. Edit code in IDE
2. **Ctrl+Alt+F11** to compile
3. Changes appear instantly in editor

### What You Get:
- `Collectible.h` - Header with declarations
- `Collectible.cpp` - Implementation

::: {.notes}
Demonstrate this live if possible. The Live Coding workflow is crucial for productivity.
:::


# Collectible Class: Header {background-color="#0f1419"}

## Collectible.h

```cpp
#pragma once
#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Collectible.generated.h"  // Always last!

class USphereComponent;
class UStaticMeshComponent;

UCLASS(BlueprintType, Blueprintable)
class MYGAME_API ACollectible : public AActor
{
    GENERATED_BODY()

public:
    ACollectible();

protected:
    // Components
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    USphereComponent* CollisionComponent;
    
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly)
    UStaticMeshComponent* MeshComponent;
    
    // Designer-editable properties
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Collectible")
    int32 PointValue = 10;
    
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Collectible")
    float RotationSpeed = 90.0f;

public:
    virtual void Tick(float DeltaTime) override;

protected:
    UFUNCTION()
    void OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
                        UPrimitiveComponent* OtherComp, int32 OtherBodyIndex,
                        bool bFromSweep, const FHitResult& SweepResult);
};
```

::: {.notes}
Point out the include order and forward declarations. BlueprintType + Blueprintable is crucial.
:::


# Collectible Class: Implementation {background-color="#0f1419"}

## Collectible.cpp

```cpp
#include "Collectible.h"
#include "Components/SphereComponent.h"
#include "Components/StaticMeshComponent.h"
#include "GameFramework/Character.h"

ACollectible::ACollectible()
{
    PrimaryActorTick.bCanEverTick = true;

    // Create collision sphere (root component)
    CollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT("CollisionSphere"));
    RootComponent = CollisionComponent;
    CollisionComponent->SetSphereRadius(100.0f);
    CollisionComponent->SetCollisionProfileName(TEXT("OverlapAllDynamic"));

    // Create mesh component (attach to collision)
    MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MeshComponent"));
    MeshComponent->SetupAttachment(RootComponent);
    MeshComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);

    // Bind overlap event
    CollisionComponent->OnComponentBeginOverlap.AddDynamic(this, &ACollectible::OnOverlapBegin);
}

void ACollectible::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    // Rotate continuously
    AddActorLocalRotation(FRotator(0.f, RotationSpeed * DeltaTime, 0.f));
}

void ACollectible::OnOverlapBegin(UPrimitiveComponent* OverlappedComp, AActor* OtherActor,
    UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
    ACharacter* PlayerCharacter = Cast<ACharacter>(OtherActor);
    if (PlayerCharacter)
    {
        UE_LOG(LogTemp, Log, TEXT("Collected for %d points!"), PointValue);
        Destroy();
    }
}
```

::: {.notes}
Emphasize component hierarchy, collision setup, and event binding. This is a complete working example.
:::


# Creating the Blueprint Child {background-color="#0f1419"}

## From C++ to Production Asset

### After compiling C++ class:

1. **Add New → Blueprint Class**
2. **Choose ACollectible as parent** (not Actor!)
3. Name: `BP_Collectible_Coin`

### In Blueprint Editor:
- **MeshComponent**: Assign coin mesh
- **Add Audio Component**: Pickup sound
- **Add Particle System**: Sparkle effects
- **Material**: Gold metallic look

### Level Usage:
- **Never** drag C++ class to level
- **Always** drag `BP_Collectible_Coin`
- Adjust `PointValue` per instance

::: {.notes}
This is the key workflow. Demonstrate if time allows. The Blueprint child is what gets used in production.
:::


# Memory Management Essentials {background-color="#0f1419"}

## Garbage Collection

```cpp
// ✅ CORRECT: GC knows about this reference
UPROPERTY()
class AMyActor* ActorReference;

// ❌ DANGEROUS: GC doesn't know about this - can cause crashes!
class AMyActor* RawPointer;

// ✅ CORRECT: For non-UObject classes
TSharedPtr<FMyCustomData> SharedData = MakeShared<FMyCustomData>();
TUniquePtr<FMyOtherData> UniqueData = MakeUnique<FMyOtherData>();
```

## Key Rules:
- **UPROPERTY()** required for UObject* references
- Use **Smart Pointers** for non-UObject classes
- Forgetting UPROPERTY() = crashes

::: {.notes}
This is a common source of bugs. UPROPERTY() on UObject pointers is not optional.
:::


# Debugging and Best Practices {background-color="#0f1419"}

## Quick Debug Tools

```cpp
// Logging
UE_LOG(LogTemp, Warning, TEXT("Health: %f, Score: %d"), Health, Score);

// Visual debugging
DrawDebugSphere(GetWorld(), GetActorLocation(), 100.f, 12, FColor::Red, false, 5.0f);

// On-screen messages
GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Yellow, TEXT("Collected!"));
```

## Performance Tips:
- Disable Tick when not needed: `PrimaryActorTick.bCanEverTick = false;`
- Use Timers instead of Tick for periodic actions
- Profile with Unreal Insights

::: {.notes}
These debugging tools will save hours of development time.
:::


# Summary and Next Steps {background-color="#0f1419"}

## Key Takeaways

### The Professional Pattern:
1. **Write gameplay logic in C++** for performance
2. **Create Blueprint children** for visual assets
3. **Place Blueprint instances** in levels, never C++ classes
4. **Use UPROPERTY()** for all UObject references

### What You've Learned:
- Essential macros (UCLASS, UPROPERTY, UFUNCTION)
- Component-based Actor architecture
- Collision and event handling
- C++ → Blueprint workflow

### Next Steps:
- Practice with more complex Actor classes
- Explore Unreal's source code for examples
- Learn about Subsystems and advanced patterns

::: {.notes}
Reinforce the core workflow and encourage continued learning. The foundation is set for more advanced topics.
:::


# Questions & Resources {background-color="#0f1419"}

## Quick Q&A

**Resources:**
- [Unreal C++ Documentation](https://docs.unrealengine.com/5.3/en-US/programming-and-scripting/)
- [Unreal C++ API Reference](https://docs.unrealengine.com/5.3/en-US/API/)
- [Community Forums](https://forums.unrealengine.com/)

**Contact:**
- Email: [gustavo.miguel.reis@gmail.com](mailto:gustavo.miguel.reis@gmail.com)
- Course Materials: [here](https://gustavo-reis.github.io/quarto-presentations/unreal_cpp_lecture/unreal_cpp_lecture.html)

::: {style="text-align: center; margin-top: 2em;"}
**Start Building with C++ + Blueprints!**
:::

::: {.notes}
Keep Q&A brief to stay on schedule. Direct people to resources for follow-up questions.
:::



