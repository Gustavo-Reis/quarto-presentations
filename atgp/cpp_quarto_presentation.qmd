---
title: "Introduction to C++"
subtitle: "A Tour of C++ - Chapters 1, 2 and 3"
author: "Gustavo Reis"
date: today
format:
  revealjs:
    theme: dracula
    transition: slide
    highlight-style: github
    code-line-numbers: true
    slide-number: true
    chalkboard: true
    preview-links: auto
    footer: "Introduction to C++"
    width: 1280
    height: 720 
---

# Overview

:::: {.columns}

::: {.column width="50%"}
**What We'll Cover:**

- History: From C to C++
- Core Language Features
- Types and Variables
- Memory Management
- Object-Oriented Programming
- Best Practices
:::

::: {.column width="50%"}
**Learning Goals:**

- Understand C++'s evolution
- Master fundamental concepts
- Learn modern C++ practices
- Build solid programming foundation
:::

::::

---

# Before C++, There Was C

## The Birth of C (1972)

::: {.incremental}
- Developed by **Dennis Ritchie** at Bell Labs
- Designed for writing operating systems
- Primary goals:
  - Minimalistic and easy to compile
  - Efficient memory access
  - High performance code generation
  - Minimal runtime support requirements
:::

## C's Impact

::: {.incremental}
- 1973: Ritchie and Ken Thompson rewrote UNIX in C
- Revolutionary move from assembly language
- Excellent portability across different CPUs
- 1978: "The C Programming Language" book published
- 1989: ANSI C standard completed
- 1990: ISO adopted C90 standard
:::

---

# The Evolution to C++

## C++ Origins (1979-1983)

::: {.incremental}
- Created by **Bjarne Stroustrup** at Bell Labs
- Originally called "C with Classes"
- 1983: Renamed to "C++" (the increment operator!)
- Goal: Make writing good programs easier and more pleasant
:::

## Key C++ Innovations

::: {.columns}

::: {.column width="50%"}
**Object-Oriented Features:**
- Classes and member functions
- Public/private access control
- Constructors and destructors
- Inheritance (derived classes)
:::

::: {.column width="50%"}
**Enhanced Language Features:**
- Function overloading
- Default arguments
- Inline functions
- Type checking
- References
:::

::::

---

# C++ Milestones

## Major Releases

::: {.incremental}
- **1986**: First edition of "The C++ Programming Language"
- **1989**: Version 2.0 - widespread adoption
- **1998**: ISO C++98 standard
- **2003**: C++03 minor update
- **2011**: C++11 - major modernization
- **2014**: C++14 - incremental improvements
- **2017**: C++17 - more features
- **2020**: C++20 - concepts and modules
:::

---

# About C++

## Key Characteristics

::: {.columns}

::: {.column width="50%"}
**Language Properties:**
- Object-oriented programming
- Statically typed
- Compiled language
- High performance
- Portable source code
:::

::: {.column width="50%"}
**Use Cases:**
- System programming
- Game development
- Embedded systems
- High-performance applications
- Financial systems
- Scientific computing
:::

::::

---

# C++ Compilation Process

## From Source to Executable

```{mermaid}
flowchart TD
    A[Source Files<br/>.cpp, .hpp] --> B[Preprocessor]
    B --> C[Compiler]
    C --> D[Object Files<br/>.o/.obj]
    D --> E[Linker]
    E --> F[Executable<br/>Program]
    
    G[Header Files<br/>.h/.hpp] --> B
    H[Libraries<br/>.lib/.a] --> E
```

## File Types

- **Header files** (`.hpp`, `.h`): Declarations, constants, type definitions
- **Source files** (`.cpp`): Implementation code
- **Object files**: Compiled machine code (not yet linked)
- **Executable**: Final runnable program

---

# Your First C++ Program

## Minimal Program

```cpp
int main() { 
    return 0; 
} // The minimal C++ program
```

::: {.incremental}
- `main()` function is the entry point
- `{ }` denote code blocks
- `//` starts single-line comments
- Return value indicates success (0) or failure (non-zero)
:::

## Hello World

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, World!\n";
    return 0;
}
```

::: {.incremental}
- `#include <iostream>` brings in I/O facilities
- `std::cout` is the standard output stream
- `<<` operator sends data to the stream
- `\n` represents newline character
:::

---

# Simplifying with Namespaces

## Using std namespace

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, World!" << endl;
    return 0;
}
```

## Functions in Action

```cpp
#include <iostream>
using namespace std;

double square(double x) {
    return x * x;
}

void print_square(double x) {
    cout << "The square of " << x 
         << " is " << square(x) << "\n";
}

int main() {
    print_square(1.234);
    return 0;
}
```

---

# Types and Variables

## Memory and Hardware Connection

::: {.incremental}
- Every name and expression has a **type**
- Type determines operations that can be performed
- Each type corresponds to **hardware facilities**
- Fixed size determines **range of values**
:::

## Fundamental Types Table

| Name | Description | Size | Range |
|------|-------------|------|-------|
| `bool` | Boolean value | 1 byte | true or false |
| `char` | Character/small integer | 1 byte | signed: -128 to 127<br/>unsigned: 0 to 255 |
| `short` | Short integer | 2 bytes | signed: -32,768 to 32,767<br/>unsigned: 0 to 65,535 |
| `int` | Integer | 4 bytes | signed: -2,147,483,648 to 2,147,483,647<br/>unsigned: 0 to 4,294,967,295 |
| `long` | Long integer | 4 bytes | signed: -2,147,483,648 to 2,147,483,647<br/>unsigned: 0 to 4,294,967,295 |
| `float` | Single precision floating point | 4 bytes | 3.4e +/- 38 (7 digits) |
| `double` | Double precision floating point | 8 bytes | 1.7e +/- 308 (15 digits) |
| `long double` | Extended precision floating point | 8+ bytes | 1.7e +/- 308 (15+ digits) |

## Memory Layout Visualization

**Visual representation of type sizes:**

```
bool:    [▓]
char:    [▓]  
int:     [▓][▓][▓][▓]
double:  [▓][▓][▓][▓][▓][▓][▓][▓]
```

- Each `[▓]` represents 1 byte (8 bits)
- `char` is always 1 byte (by definition)
- Other sizes are implementation-defined but typically as shown

---

# Type Checking Example

## Understanding sizeof Operator

```cpp
#include <iostream>
using namespace std;

int main() {
    cout << "The size of a bool is:\t\t" << sizeof(bool) << " bytes\n";
    cout << "The size of a char is:\t\t" << sizeof(char) << " bytes\n";
    cout << "The size of a short int is:\t" << sizeof(short) << " bytes\n";
    cout << "The size of an int is:\t\t" << sizeof(int) << " bytes\n";
    cout << "The size of a long int is:\t" << sizeof(long) << " bytes\n";
    cout << "The size of a float is:\t\t" << sizeof(float) << " bytes\n";
    cout << "The size of a double is:\t" << sizeof(double) << " bytes\n";
    return 0;
}
```

**Typical Output:**
```
The size of a bool is:      1 bytes
The size of a char is:      1 bytes  
The size of a short int is: 2 bytes
The size of an int is:      4 bytes
The size of a long int is:  4 bytes
The size of a float is:     4 bytes
The size of a double is:    8 bytes
```

## Important Notes

::: {.incremental}
- `sizeof(char)` is **always** 1 byte (by C++ standard)
- Other sizes are **implementation-defined** (may vary between systems)
- Size determines the **range of values** that can be stored
- `sizeof` operator returns size in **multiples of char size**
:::

---

# Type Conversions and Mixing

## Implicit Type Conversions

```cpp
void some_function() {
    double d = 2.2;   // initialize floating point number
    int i = 7;        // initialize integer
    d = d + i;        // assign sum to d (i converted to double)
    i = d * i;        // assign product to i (truncating double to int)
}
```

::: {.incremental}
- C++ performs **meaningful conversions** between basic types
- Types can be **mixed freely** in expressions
- **Implicit conversion** may cause **data loss** (double → int)
- Compiler usually issues **warnings** for narrowing conversions
:::

## Variable Declarations and Definitions

```cpp
// Declaration vs Definition
extern int x;           // Declaration only
int x = 10;            // Definition (declaration + storage allocation)

// Type, object, value, and variable relationships
int inch;              // inch is of type int
                      // inch is a variable (named object)
                      // some memory holds a value of type int
```

## Key Terminology

::: {.incremental}
- **Type**: defines set of possible values and operations
- **Object**: memory that holds a value of some type  
- **Value**: set of bits interpreted according to a type
- **Variable**: named object
- **Declaration**: introduces name and specifies type
- **Definition**: declaration + memory allocation
:::

## Arithmetic Operators

```cpp
int a = 10, b = 3;
int sum = a + b;        // Addition: 13
int diff = a - b;       // Subtraction: 7
int product = a * b;    // Multiplication: 30
int quotient = a / b;   // Division: 3
int remainder = a % b;  // Modulus: 1
```

## Comparison Operators

```cpp
bool equal = (a == b);      // false
bool notEqual = (a != b);   // true
bool greater = (a > b);     // true
bool lessEqual = (a <= b);  // false
```

## Assignment Shortcuts

```cpp
a += 5;  // a = a + 5
a *= 2;  // a = a * 2
++a;     // a = a + 1 (prefix)
a++;     // a = a + 1 (postfix)
```

---

# Modern Initialization

## Traditional vs Modern

```cpp
// Traditional initialization
double d1 = 2.3;
int i1 = 7;

// Modern uniform initialization
double d2{2.3};
int i2{7};
complex<double> z{1.0, 2.0};
```

## Type Safety Benefits

```cpp
int i1 = 7.2;   // OK: i1 becomes 7 (loses precision)
int i2{7.2};    // ERROR: prevents data loss
```

## Automatic Type Deduction

```cpp
auto b = true;        // bool
auto ch = 'x';        // char
auto i = 123;         // int
auto d = 1.2;         // double
auto result = sqrt(9); // depends on sqrt return type
```

---

# Scope and Lifetime

## Types of Scope

::: {.columns}

::: {.column width="50%"}
**Local Scope:**
```cpp
void function() {
    int x = 10;  // local variable
    if (x > 5) {
        int y = 20;  // block scope
        // y dies here
    }
    // x dies here
}
```
:::

::: {.column width="50%"}
**Global Scope:**
```cpp
int globalVar = 100;  // global

class MyClass {
    int member;       // class scope
public:
    void method();
};

namespace MySpace {
    int nsVar;        // namespace scope
}
```
:::

::::

## Static Local Variables

```cpp
void counter() {
    static int count = 0;  // initialized once
    cout << "Called " << ++count << " times\n";
}

int main() {
    counter();  // Output: Called 1 times
    counter();  // Output: Called 2 times
    counter();  // Output: Called 3 times
}
```

---

# Constants

## const vs constexpr

::: {.columns}

::: {.column width="50%"}
**const** - Runtime constant:
```cpp
const int size = 10;
const double pi = 3.14159;

void process(const vector<int>& data) {
    // data cannot be modified
}
```
:::

::: {.column width="50%"}
**constexpr** - Compile-time constant:
```cpp
constexpr double gravity = 9.81;
constexpr int square(int x) {
    return x * x;
}

constexpr int result = square(5); // OK
```
:::

::::

## Example Usage

```cpp
const int runtime_size = get_user_input();  // OK
constexpr int compile_size = 100;           // OK

// Array size must be compile-time constant
int array1[compile_size];    // OK
int array2[runtime_size];    // ERROR
```

---

# Arrays and Collections

## Traditional Arrays

```cpp
int numbers[5] = {1, 2, 3, 4, 5};

// Traditional loop
for (int i = 0; i < 5; ++i) {
    cout << numbers[i] << " ";
}

// Range-based loop (C++11)
for (int num : numbers) {
    cout << num << " ";
}

// Auto with references
for (auto& num : numbers) {
    num *= 2;  // doubles each element
}
```

---

# Pointers

## Pointer Fundamentals

::: {.columns}

::: {.column width="60%"}
```cpp
int value = 42;
int* ptr = &value;  // ptr stores address of value

cout << "Value: " << value << "\n";        // 42
cout << "Address: " << &value << "\n";     // 0x7fff...
cout << "Pointer: " << ptr << "\n";        // 0x7fff...
cout << "Dereferenced: " << *ptr << "\n";  // 42

*ptr = 100;  // Changes value through pointer
cout << "New value: " << value << "\n";    // 100
```
:::

::: {.column width="40%"}
**Memory Layout:**
```
Memory Address: 0x7fff5fc
┌─────────────┐
│    100      │  value
└─────────────┘
       ↑
┌─────────────┐
│ 0x7fff5fc   │  ptr
└─────────────┘
```
:::

::::

## Pointer Example: Swap Function

```cpp
void swap_by_pointer(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 10, y = 20;
    cout << "Before: x=" << x << ", y=" << y << "\n";
    
    swap_by_pointer(&x, &y);
    
    cout << "After: x=" << x << ", y=" << y << "\n";
    return 0;
}
```

---

# Null Pointers and Safety

## The nullptr Concept

::: {.incremental}
- We should ensure pointers **always point to valid objects**
- When no object available, use **`nullptr`** ("the null pointer")
- Represents "**no object available**" (e.g., end of list)
- **One `nullptr`** shared by all pointer types
:::

## nullptr Examples

```cpp
double* pd = nullptr;           // OK: pointer to double
int* pi = nullptr;              // OK: pointer to int  
int x = nullptr;                // ERROR: nullptr is not an integer

// Always check before dereferencing
int count_chars(char* p, char target) {
    if (p == nullptr) return 0;  // Safety check
    
    int count = 0;
    for (; *p != 0; ++p) {       // C-style string (zero-terminated)
        if (*p == target) ++count;
    }
    return count;
}
```

## Legacy vs Modern

::: {.columns}

::: {.column width="50%"}
**Old Style (avoid):**
```cpp
int* ptr = NULL;    // Old C style
int* ptr2 = 0;      // Confusing with integer
```
:::

::: {.column width="50%"}
**Modern Style:**
```cpp
int* ptr = nullptr; // Clear, type-safe
if (ptr != nullptr) {
    // Safe to dereference
}
```
:::

::::

## Reference Fundamentals

```cpp
int original = 42;
int& ref = original;  // ref is an alias for original

ref = 100;           // Changes original
cout << original;    // Output: 100

// References must be initialized
int& invalid_ref;    // ERROR: must initialize
```

## References vs Pointers

::: {.columns}

::: {.column width="50%"}
**Pointers:**
```cpp
int* ptr;           // Can be uninitialized
ptr = nullptr;      // Can be null
ptr = &other_var;   // Can be reassigned
cout << *ptr;       // Requires dereferencing
```
:::

::: {.column width="50%"}
**References:**
```cpp
int& ref = var;     // Must be initialized
// ref = nullptr;   // ERROR: cannot be null
// ref = other_var; // ERROR: cannot reassign
cout << ref;        // Direct access
```
:::

::::

## Function Parameters with References

```cpp
void swap_by_reference(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// Const references avoid copying
double sum(const vector<double>& numbers) {
    double total = 0;
    for (double num : numbers) {
        total += num;
    }
    return total;
}
```

---

# User-Defined Types

## Structures

```cpp
struct Point {
    double x;
    double y;
    
    // Constructor
    Point(double x_val, double y_val) : x(x_val), y(y_val) {}
    
    // Member function
    double distance_from_origin() const {
        return sqrt(x*x + y*y);
    }
};

Point p1(3.0, 4.0);
cout << "Distance: " << p1.distance_from_origin(); // 5.0
```

## Accessing Members

```cpp
Point p(1, 2);
Point* ptr = &p;

cout << p.x;        // Direct access
cout << ptr->x;     // Pointer access
```

---

# Classes

## Class Definition

```cpp
class Vector {
private:
    double* elements;
    int size_;
    
public:
    // Constructor
    Vector(int s) : elements(new double[s]), size_(s) {}
    
    // Destructor
    ~Vector() { delete[] elements; }
    
    // Accessor
    double& operator[](int i) { return elements[i]; }
    const double& operator[](int i) const { return elements[i]; }
    
    // Size function
    int size() const { return size_; }
};
```

## Using the Class

```cpp
Vector v(5);
for (int i = 0; i < v.size(); ++i) {
    v[i] = i * 1.5;
}

for (int i = 0; i < v.size(); ++i) {
    cout << v[i] << " ";
}
```

---

# Enumerations

## Strongly-Typed Enums

```cpp
enum class Color { Red, Green, Blue };
enum class TrafficLight { Red, Yellow, Green };

Color favorite = Color::Blue;
TrafficLight signal = TrafficLight::Red;

// Type safety
if (favorite == Color::Red) {          // OK
    cout << "Red is favorite\n";
}

// This won't compile:
// if (favorite == TrafficLight::Red) { ... }  // ERROR
```

## Custom Enum Operations

```cpp
TrafficLight& operator++(TrafficLight& light) {
    switch (light) {
        case TrafficLight::Red:    return light = TrafficLight::Green;
        case TrafficLight::Yellow: return light = TrafficLight::Red;
        case TrafficLight::Green:  return light = TrafficLight::Yellow;
    }
}

TrafficLight current = TrafficLight::Red;
++current;  // Now Green
```

---

# Error Handling and Invariants

## Class Invariants Theory

::: {.incremental}
- **Precondition**: What must be true when function is called
- **Postcondition**: What function guarantees upon return
- **Class Invariant**: What is assumed true for a class at all times
- Constructor establishes invariant, member functions maintain it
:::

## Example: Vector Class Invariant

```cpp
class Vector {
private:
    double* elem;    // elem points to an array of sz doubles
    int sz;         // sz >= 0
    
public:
    Vector(int s) : sz{s} {
        if (s < 0) throw length_error{"negative size"};  // Check precondition
        elem = new double[s];                            // Establish invariant
    }
    
    double& operator[](int i) {
        if (i < 0 || sz <= i) throw out_of_range{"Vector::operator[]"};
        return elem[i];                                  // Maintain invariant
    }
};
```

**Class Invariant:** *"elem points to an array of sz doubles, where sz >= 0"*

## Exception Handling Pattern

```cpp
void safe_vector_usage() {
    try {
        Vector v(-5);        // Will throw length_error
    }
    catch (length_error& e) {
        cout << "Construction failed: " << e.what() << "\n";
    }
    catch (bad_alloc& e) {
        cout << "Memory allocation failed: " << e.what() << "\n";
    }
}
```

::: {.incremental}
- Exceptions **transfer control** to appropriate handler
- Implementation **unwinds call stack** to find handler
- **out_of_range** and **length_error** are standard library exceptions
- Always **specify preconditions** and test them when feasible
:::

---

# Unions: Memory Efficiency

## Understanding Unions

::: {.incremental}
- A `union` is a `struct` where **all members share the same memory**
- Union occupies space of its **largest member only**  
- Only **one member** can hold a value at any time
- Used to **save memory** when alternatives are mutually exclusive
:::

## Union Example: Before and After

::: {.columns}

::: {.column width="50%"}
**Wasteful struct:**
```cpp
enum Type {str, num};

struct Entry {
    char* name;
    Type t;
    char* s;    // use if t == str
    int i;      // use if t == num
};
// Wastes space: both s and i 
// are allocated but only one used
```
:::

::: {.column width="50%"}
**Efficient with union:**
```cpp
union Value {
    char* s;
    int i;
};

struct Entry {
    char* name;
    Type t;
    Value v;    // v.s or v.i
};
// Saves memory: s and i 
// share same location
```
:::

::::

## Important Union Considerations

```cpp
void process_entry(Entry* p) {
    if (p->t == str) {
        cout << p->v.s;       // Use string member
    } else if (p->t == num) {
        cout << p->v.i;       // Use integer member
    }
}
```

::: {.incremental}
- Language **doesn't track** which member is active
- Programmer **must maintain** type correspondence
- **Error-prone** - easy to access wrong member
- Best practice: **encapsulate unions** in classes
- Modern alternative: `std::variant` (C++17)
:::

## RAII Principle

**Resource Acquisition Is Initialization**

```cpp
class SafeVector {
private:
    unique_ptr<double[]> elements;
    int size_;
    
public:
    SafeVector(int s) : elements(make_unique<double[]>(s)), size_(s) {}
    
    // No need for explicit destructor!
    // unique_ptr handles cleanup automatically
    
    double& operator[](int i) { return elements[i]; }
    int size() const { return size_; }
};
```

## Modern Memory Management

```cpp
// Prefer smart pointers
auto ptr = make_unique<Vector>(10);     // Automatic cleanup
auto shared = make_shared<Vector>(10);  // Reference counted

// Avoid raw pointers for ownership
Vector* raw = new Vector(10);  // Don't do this!
delete raw;                    // Easy to forget!
```

---

# Static Assertions

## Compile-Time Checks

```cpp
// Check type sizes
static_assert(sizeof(int) >= 4, "int must be at least 4 bytes");

// Check template parameters
template<typename T>
class MyClass {
    static_assert(is_arithmetic_v<T>, "T must be arithmetic");
    // ...
};

// Check constants
constexpr int BUFFER_SIZE = 1024;
static_assert(BUFFER_SIZE > 0, "Buffer size must be positive");
```

---

# Separate Compilation

## Header File (Vector.hpp)

```cpp
#ifndef VECTOR_HPP
#define VECTOR_HPP

class Vector {
private:
    double* elements;
    int size_;
    
public:
    Vector(int s);
    ~Vector();
    
    double& operator[](int i);
    const double& operator[](int i) const;
    int size() const;
};

#endif
```

## Implementation File (Vector.cpp)

```cpp
#include "Vector.hpp"
#include <stdexcept>

Vector::Vector(int s) : size_(s) {
    if (s < 0) throw std::length_error("Negative size");
    elements = new double[s];
}

Vector::~Vector() {
    delete[] elements;
}

double& Vector::operator[](int i) {
    if (i < 0 || i >= size_) 
        throw std::out_of_range("Index out of range");
    return elements[i];
}

int Vector::size() const {
    return size_;
}
```

---

# Namespaces

## Organizing Code

```cpp
namespace Graphics {
    class Point {
        double x, y;
    public:
        Point(double x, double y) : x(x), y(y) {}
        // ...
    };
    
    namespace Colors {
        constexpr int RED = 0xFF0000;
        constexpr int GREEN = 0x00FF00;
        constexpr int BLUE = 0x0000FF;
    }
}

// Usage
Graphics::Point p(1, 2);
int red = Graphics::Colors::RED;

// Using declarations
using Graphics::Point;
using namespace Graphics::Colors;

Point p2(3, 4);  // Now we can use Point directly
int blue = BLUE; // And colors directly
```

---

# Best Practices Summary

## Modern C++ Guidelines

::: {.columns}

::: {.column width="50%"}
**Memory Management:**
- Use smart pointers (`unique_ptr`, `shared_ptr`)
- Follow RAII principles
- Avoid raw `new`/`delete`

**Type Safety:**
- Use `auto` for type deduction
- Prefer `{}` initialization
- Use `constexpr` when possible
:::

::: {.column width="50%"}
**Code Organization:**
- Separate interface from implementation
- Use namespaces to organize code
- Make interfaces `const`-correct

**Error Handling:**
- Use exceptions for error reporting
- Check preconditions
- Use `static_assert` for compile-time checks
:::

::::

## Performance Tips

- Pass large objects by `const` reference
- Use range-based for loops
- Prefer algorithms over raw loops
- Enable compiler optimizations

---

# What's Next?

## Advanced Topics to Explore

::: {.columns}

::: {.column width="50%"}
**Object-Oriented Programming:**
- Inheritance and polymorphism
- Virtual functions
- Abstract classes
- Design patterns
:::

::: {.column width="50%"}
**Generic Programming:**
- Templates and template specialization
- STL containers and algorithms
- Function objects and lambdas
- Concepts (C++20)
:::

::::

## Modern C++ Features

- Move semantics and perfect forwarding
- Lambda expressions
- Multithreading support
- Modules (C++20)
- Ranges library (C++20)

---

# Thank You!

## Questions?

**Resources for Further Learning:**

- [C++ Reference](https://cppreference.com)
- "A Tour of C++" by Bjarne Stroustrup
- [Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/)
- [Compiler Explorer](https://godbolt.org)

**Practice Platforms:**
- [LeetCode](https://leetcode.com)
- [HackerRank](https://hackerrank.com)
- [Codeforces](https://codeforces.com)