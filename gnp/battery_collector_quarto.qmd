---
title: "C++ 3rd Person Battery Collector Power Up Game"
subtitle: "GAME ENGINES II"
author: "Gustavo Reis"
date: "2022/2023 - 2nd Semester"
format:
  html:
    theme: cosmo
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: false
    highlight-style: github
  pdf:
    toc: true
    number-sections: true
---

## Introduction

This assignment will introduce you to C++ programming and Unreal Engine 5 (UE5), including some of the Gameplay Framework classes. It will also show you some of the different ways to work with classes, functions, and variables that can help you with your project. This is just a jumping off point to get you started, but it is a mini game with both winning and losing.

As you will see, the character can collect batteries which are spawned by a Spawn Volume above the level. Your power increases as you collect the batteries, which changes your material and your running speed. However, the GameMode is also draining your character over time. You can lose power completely.

By the end of this assignment, you will have a number of classes including:

- **Base pickup** - A battery pickup which fires lightning towards the character and gives some of its base power to the character
- **Upgraded character** - Has a Collection Sphere to collect all of the batteries within a certain radius of the character
- **GameMode** - Drains the character's power over time and defines what happens when you win and when you lose during gameplay
- **Spawn Volume** - Spawns any kind of pickup whether it is a Base Pickup, a Battery Pickup, or some other kind of pickup that you develop on your own
- **HUD** - Set up using UMG (Unreal Motion Graphics) and has the power bar and the text at the top of the screen

## Building the Base Level

### Setting Up the Project

Open the Games tab in the Unreal Project Browser. We are going to use a C++ template. Select **Third Person**. Leave the setup on Desktop. You can change the quality to Maximum Quality or Scalable, depending on your system setup.

::: {.callout-important}
The reason for not changing from Desktop to Mobile is that will change some of the inputs for your project.
:::

You can either include Starter Content or not; we don't need it for this assignment. However, if you want to take the project further, you can add Starter Content now or add it later with the add Feature Packs in the editor.

**Name the project "BatteryCollector"**. If you name your project something different, you will have to adjust the code from the assignment. Click **Create**.

### Importing Content from Content Examples

You need to use content from the Content Examples project. Download it from the Epic Games Launcher.

There are 2 things you are going to use from the Content Examples project:
1. A room for the character to run around
2. A battery mesh for our battery pickup

#### Migrating the Demo Room

In the Content Drawer, search for "BP_DemoRoom". This is the room we are going to use.

1. Select **BP_DemoRoom** in the Content Drawer
2. Right-click, go to **Asset Actions** and select **Migrate**
3. Click **OK** when the asset list appears
4. Navigate to your project: `UnrealProjects > BatteryCollector > Content`
5. Click **Select Folder**

#### Migrating the Battery Mesh

Search for "Battery". Select the **SM_Battery_Medium**.
1. Right-click, go to **Asset Actions**, and select **Migrate**
2. Click **OK**
3. The Content folder should still be selected, click **OK**

### Setting Up the Level

1. Create a new level: **File → New Level → Basic**
2. Create a **Maps** folder within the Content folder
3. Save the level as "**CollectionLevel**" in the Maps folder

#### Setting Default Maps

1. Click **Edit → Project Settings**
2. Select **Maps & Modes**
3. Set both **Game Default Map** and **Editor Startup Map** to **CollectionLevel**

### Level Design Setup

1. Delete the Floor from the World Outliner
2. Drag **BP_DemoRoom** into the level
3. Configure the room properties:
   - Set **Width** to 32
   - Uncheck **Pillar** and **Sub Pillar**
   - Uncheck **Enclosed Left** (batteries will fall from the sky)

4. Add a **Player Start** actor:
   - **Window → Place Actors**
   - Search for **Player Start** and drag it to the center of the room

## Making Your First Pickup Class

### Creating the Base Pickup Class

Use the C++ Class Wizard: **Tools → New C++ Class**

1. Select **Actor** as the parent class
2. Name the class "**Pickup**"
3. Click **Create Class**

### Pickup Header File (Pickup.h)

```cpp
// Fill out your copyright notice in the Description page of Project Settings.
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include "Pickup.generated.h"

UCLASS()
class BATTERYCOLLECTOR_API APickup : public AActor
{
    GENERATED_BODY()
    
public:    
    // Sets default values for this actor's properties
    APickup();

protected:
    // Called when the game starts or when spawned
    virtual void BeginPlay() override;
    
    /** True when the pickup can be used, and false when the pickup is deactivated */
    bool bIsActive;

public:    
    // Called every frame
    virtual void Tick(float DeltaTime) override;
    
    /** Return the mesh for the pickup */
    FORCEINLINE UStaticMeshComponent* GetMesh() const { return PickupMesh; }
    
    /** Return whether or not the pickup is active */
    UFUNCTION(BlueprintPure, Category = "Pickup")
    bool IsActive();
    
    /** Allows other classes to safely change whether or not pickup is active */
    UFUNCTION(BlueprintCallable, Category = "Pickup")
    void SetActive(bool NewPickupState);

private:
    /** Static mesh to represent the pickup in the level */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Pickup", meta = (allowprivateaccess = true))
    UStaticMeshComponent* PickupMesh;
};
```

### Pickup Source File (Pickup.cpp)

```cpp
// Fill out your copyright notice in the Description page of Project Settings.
#include "Pickup.h"

// Sets default values
APickup::APickup()
{
    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.
    PrimaryActorTick.bCanEverTick = false;
    
    // All pickups start active
    bIsActive = true;
    
    // Create the static mesh component
    PickupMesh = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("PickupMesh"));
    RootComponent = PickupMesh;
}

// Called when the game starts or when spawned
void APickup::BeginPlay()
{
    Super::BeginPlay();
}

// Called every frame
void APickup::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
}

// Returns active state
bool APickup::IsActive()
{
    return bIsActive;
}

// Changes active state
void APickup::SetActive(bool NewPickupState)
{
    bIsActive = NewPickupState;
}
```

### Creating a Blueprint from the Pickup Class

1. Right-click on **Pickup** in C++ Classes
2. Select **Create Blueprint class based on Pickup**
3. Name it "**Pickup_BP**" and save it in the Blueprints folder
4. Set the **Static Mesh** to **SM_Cube**
5. Compile and Save

## Extending the Pickup Class

### Creating the Battery Pickup Class

Create a new C++ class derived from Pickup:

1. **Tools → New C++ Class**
2. Click **All Classes** and search for "Pickup"
3. Select **Pickup** and click **Next**
4. Name the class "**BatteryPickup**"

### Battery Pickup Header File (BatteryPickup.h)

```cpp
// Fill out your copyright notice in the Description page of Project Settings.
#pragma once

#include "CoreMinimal.h"
#include "Pickup.h"
#include "BatteryPickup.generated.h"

UCLASS()
class BATTERYCOLLECTOR_API ABatteryPickup : public APickup
{
    GENERATED_BODY()

public:
    ABatteryPickup();
    
    /** Override the WasCollected function - use Implementation because it's a Blueprint Native Event */
    void WasCollected_Implementation() override;

protected:
    /** Set the amount of power the battery gives to the character */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Power", Meta = (BlueprintProtected = "true"))
    float BatteryPower;
    
public:
    /** Public way to access the battery's power level */
    float GetPower();
};
```

### Battery Pickup Source File (BatteryPickup.cpp)

```cpp
// Fill out your copyright notice in the Description page of Project Settings.
#include "BatteryPickup.h"

ABatteryPickup::ABatteryPickup()
{
    GetMesh()->SetSimulatePhysics(true);
    
    // The base power level of the battery
    BatteryPower = 150.f;
}

void ABatteryPickup::WasCollected_Implementation()
{
    // Use the base pickup behavior
    Super::WasCollected_Implementation();
    
    // Destroy the battery
    Destroy();
}

// Report the power level of the battery
float ABatteryPickup::GetPower()
{
    return BatteryPower;
}
```

### Setting Up Battery Collision

The battery needs collision to stop falling through the floor:

1. Open **SM_Battery_Medium** in the Static Mesh Editor
2. Click **Collision → Add 18DOP Simplified Collision**
3. Save the mesh

### Creating Battery Blueprint

1. Right-click **BatteryPickup** and select **Create Blueprint class based on BatteryPickup**
2. Name it "**Battery_BP**"
3. Set the **Static Mesh** to **SM_Battery_Medium**
4. Compile and Save

## Creating the Spawning Volume

### Spawn Volume Class

Create a new Actor class called "**SpawnVolume**".

### Spawn Volume Header File (SpawnVolume.h)

```cpp
#include "CoreMinimal.h"
#include "GameFramework/Actor.h"
#include <Components/BoxComponent.h>
#include <Kismet/KismetMathLibrary.h>
#include "Pickup.h"
#include "SpawnVolume.generated.h"

UCLASS()
class BATTERYCOLLECTOR_API ASpawnVolume : public AActor
{
    GENERATED_BODY()
    
public:    
    // Sets default values for this actor's properties
    ASpawnVolume();

protected:
    // Called when the game starts or when spawned
    virtual void BeginPlay() override;
    
    /** The pickup to spawn */
    UPROPERTY(EditAnywhere, Category = "Spawning")
    TSubclassOf<class APickup> WhatToSpawn;
    
    FTimerHandle SpawnTimer;
    
    /** Minimum spawn delay */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Spawning")
    float SpawnDelayRangeLow;
    
    /** Maximum spawn delay */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Spawning")
    float SpawnDelayRangeHigh;

public:    
    // Called every frame
    virtual void Tick(float DeltaTime) override;
    
    /** Returns the WhereToSpawn subobject */
    FORCEINLINE class UBoxComponent* GetWhereToSpawn() const { return WhereToSpawn; }
    
    /** Find a random point within the BoxComponent */
    UFUNCTION(BlueprintPure, Category = "Spawning")
    FVector GetRandomPointInVolume();
    
    /** This function toggles whether or not the spawn volume spawns pickups */
    UFUNCTION(BlueprintCallable, Category = "Spawning")
    void SetSpawningActive(bool bShouldSpawn);

private:
    /** Box Component to specify where the pickups should be spawned */
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Spawning", meta = (AllowPrivateAccess = "true"))
    UBoxComponent* WhereToSpawn;
    
    /** Handle spawning a new pickup */
    void SpawnPickup();
    
    /** The current spawn delay */
    float SpawnDelay;
};
```

### Spawn Volume Source File (SpawnVolume.cpp)

```cpp
#include "SpawnVolume.h"
#include <Kismet/GameplayStatics.h>

// Sets default values
ASpawnVolume::ASpawnVolume()
{
    // Set this actor to call Tick() every frame. You can turn this off to improve performance if you don't need it.
    PrimaryActorTick.bCanEverTick = false;
    
    // Create the Box Component to represent the spawn volume
    WhereToSpawn = CreateDefaultSubobject<UBoxComponent>(TEXT("WhereToSpawn"));
    RootComponent = WhereToSpawn;
    
    // Set the spawn delay range
    SpawnDelayRangeLow = 1.0f;
    SpawnDelayRangeHigh = 4.5f;
}

// Called when the game starts or when spawned
void ASpawnVolume::BeginPlay()
{
    Super::BeginPlay();
}

// Called every frame
void ASpawnVolume::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
}

FVector ASpawnVolume::GetRandomPointInVolume()
{
    FVector SpawnOrigin = WhereToSpawn->Bounds.Origin;
    FVector SpawnExtent = WhereToSpawn->Bounds.BoxExtent;
    
    return UKismetMathLibrary::RandomPointInBoundingBox(SpawnOrigin, SpawnExtent);
}

void ASpawnVolume::SetSpawningActive(bool bShouldSpawn)
{
    if (bShouldSpawn)
    {
        // Set the timer on Spawn Pickup
        SpawnDelay = FMath::FRandRange(SpawnDelayRangeLow, SpawnDelayRangeHigh);
        GetWorldTimerManager().SetTimer(SpawnTimer, this, &ASpawnVolume::SpawnPickup, SpawnDelay, false);
    }
    else
    {
        // Clear the timer on Spawn Pickup
        GetWorldTimerManager().ClearTimer(SpawnTimer);
    }
}

void ABatteryCollectorGameMode::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    
    // Check that we are using the battery collector character 
    ABatteryCollectorCharacter* MyCharacter = Cast<ABatteryCollectorCharacter>(UGameplayStatics::GetPlayerPawn(this, 0));
    if (MyCharacter)
    {
        // If our power is greater than needed to win, set the game's state to Won
        if (MyCharacter->GetCurrentPower() > PowerToWin)
        {
            SetCurrentState(EBatteryPlayState::EWon);
        }
        // If the character's power is positive
        else if (MyCharacter->GetCurrentPower() > 0)
        {
            // Decrease the character's power using the decay rate
            MyCharacter->UpdatePower(-DeltaTime * DecayRate * (MyCharacter->GetInitialPower()));
        }
        else
        {
            SetCurrentState(EBatteryPlayState::EGameOver);
        }
    }
}
```

## Final Setup and Polish

### Creating GameMode Blueprint

1. Create a **GameMode_BP** Blueprint based on **BatteryCollectorGameMode**
2. Set **HUDWidget Class** to **BatteryHUD**
3. Set this as the **Default GameMode** in **Project Settings → Maps & Modes**

### Character Collision Setup

In **BP_ThirdPersonCharacter**:

1. Select the **Mesh** component
2. Set **Collision Presets** to **Ragdoll** (so the character collides when ragdolled)

### Level Polish

#### Spawn Volume Setup

1. Position the spawn volume above the room
2. Scale it to cover most of the playing area
3. Set appropriate spawn delay ranges
4. Ensure **What to Spawn** is set to **Battery_BP**

#### Lighting and Visual Polish

1. Build lighting for the final room setup
2. Adjust **Decay Rate** in **GameMode_BP** for balanced gameplay
3. Test win/lose conditions

### HUD Text Styling

In **BatteryHUD**:

1. Increase **Font Size** to 48 for better visibility
2. Set up proper anchoring for responsive design
3. Ensure text is centered and visible

## Testing the Complete Game

The completed game should have:

- **Character movement** and collection mechanics
- **Power system** with visual feedback (color changes, speed changes)
- **Battery spawning** from spawn volumes
- **Electric arc effects** when collecting batteries
- **HUD** showing power level and game state
- **Win condition** when power exceeds PowerToWin threshold
- **Lose condition** when power reaches zero (with ragdoll effect)
- **Game state management** that stops spawning and disables input appropriately

## Exercises

Using what you have learned throughout this assignment, try to do the following:

### Basic Extensions

1. **Character Glow Effect**
   - Make your Character glow as you collect batteries
   - Hint: Use emissive materials or particle effects

2. **Battery Counter**
   - Show the number of batteries you have collected on a counter in the corner
   - Add a variable to track collected battery count

3. **Night Scene**
   - Make it a nighttime scene by playing with the sky sphere and the directional light
   - Experiment with atmospheric lighting

### Intermediate Extensions

4. **Red Battery Variant**
   - Create a copy of the original SM_Battery_Medium mesh
   - Change its material to become red instead of orange
   - Create a new type of Battery with 300 power

5. **Special Pickup System**
   - Create a new type of Spawn Volume with probability-based spawning
   - Add a probability parameter (default value = 0.1) for special battery pickups
   - Set the red battery as the special type of pickup

### Advanced Extensions

6. **Enhanced Spawn Volume**
   - Create a spawn volume that can spawn multiple pickup types
   - Implement weighted random selection for different pickup types
   - Add configuration for spawn probabilities per pickup type

## Troubleshooting

### Common Issues

::: {.callout-warning}
**Batteries Falling Through Floor**
- Ensure collision is set up on SM_Battery_Medium
- Use 18DOP Simplified Collision for better rolling behavior
:::

::: {.callout-warning}
**Character Not Ragdolling**
- Check that Mesh collision is set to "Ragdoll" preset
- Ensure SetSimulatePhysics(true) is being called
:::

::: {.callout-warning}
**Spawn Volumes Not Working**
- Verify GameMode is finding and registering spawn volumes
- Check that SetSpawningActive(true) is being called in EPlaying state
- Ensure WhatToSpawn is set to a valid pickup class
:::

### Performance Considerations

- **Spawn Rate Balance**: Too many spawned pickups can affect performance
- **Particle Effects**: Electric arcs create temporary particle systems
- **Collection Sphere**: Large radii may impact collision detection performance

## Conclusion

This assignment demonstrates fundamental game development concepts in Unreal Engine 5 with C++:

- **Object-Oriented Design**: Inheritance hierarchy with base and derived pickup classes
- **Component-Based Architecture**: Using UE5's component system for modular functionality
- **Game State Management**: Implementing different game states with appropriate transitions
- **UI Integration**: Creating responsive HUDs with UMG
- **Physics Integration**: Combining physics simulation with gameplay mechanics
- **Visual Effects**: Particle systems and dynamic material changes
- **Input Handling**: Enhanced Input System integration

The modular design allows for easy extension - new pickup types, different game modes, and additional mechanics can be added by following the established patterns.

## Source Reference

**Source**: [https://www.youtube.com/playlist?list=PLZlv_N0_O1gYup-gvJtMsgJqnEB_dGiM4](https://www.youtube.com/playlist?list=PLZlv_N0_O1gYup-gvJtMsgJqnEB_dGiM4)

---

*This document was converted from the original PDF assignment for the Games and Multimedia - Game Engines II course, Academic Year 2022/2023, 2nd Semester.*

void ASpawnVolume::SpawnPickup()
{
    // If we have something to spawn:
    if (WhatToSpawn != nullptr)
    {
        // Check for a valid World:
        UWorld* const World = GetWorld();
        if (World)
        {
            // Set the spawn parameters
            FActorSpawnParameters SpawnParams;
            SpawnParams.Owner = this;
            SpawnParams.Instigator = GetInstigator();
            
            // Get a random location to spawn at
            FVector SpawnLocation = GetRandomPointInVolume();
            
            // Get a random rotation for the spawned item
            FRotator SpawnRotation;
            SpawnRotation.Yaw = FMath::FRand() * 360.0f;
            SpawnRotation.Pitch = FMath::FRand() * 360.0f;
            SpawnRotation.Roll = FMath::FRand() * 360.0f;
            
            // Spawn the pickup
            APickup* const SpawnedPickup = World->SpawnActor<APickup>(WhatToSpawn, SpawnLocation, SpawnRotation, SpawnParams);
            
            SpawnDelay = FMath::FRandRange(SpawnDelayRangeLow, SpawnDelayRangeHigh);
            GetWorldTimerManager().SetTimer(SpawnTimer, this, &ASpawnVolume::SpawnPickup, SpawnDelay, false);
        }
    }
}
```

### Setting Up Spawn Volumes in Level

1. Drag **SpawnVolume** directly into your level
2. Scale it appropriately using the **R** key
3. In the Details panel, set **What to Spawn** to **Battery_BP**
4. Adjust **Spawn Delay Range Low** and **High** values as needed

## Extending the Character Class

### Adding Collection Sphere

In **BatteryCollectorCharacter.h**, add the collection sphere:

```cpp
/** Collection sphere */
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Pickups, meta = (AllowPrivateAccess = "true"))
class USphereComponent* CollectionSphere;

/** Return CollectionSphere subobject **/
FORCEINLINE class USphereComponent* GetCollectionSphere() const { return CollectionSphere; }
```

In **BatteryCollectorCharacter.cpp** constructor:

```cpp
// Create the collection sphere
CollectionSphere = CreateDefaultSubobject<USphereComponent>(TEXT("CollectionSphere"));
CollectionSphere->SetupAttachment(RootComponent);
CollectionSphere->SetSphereRadius(200.f);
```

### Adding Collection Functions

Add to the header file:

```cpp
/** Called when we press a key to collect any pickups inside the CollectionSphere */
UFUNCTION(BlueprintCallable, Category = "Pickups")
void CollectPickups();
```

### Adding Pickup Collection Logic

In **BatteryCollectorCharacter.cpp**:

```cpp
#include "Pickup.h"

void ABatteryCollectorCharacter::CollectPickups()
{
    // Get all overlapping Actors and store them in an array
    TArray<AActor*> CollectedActors;
    CollectionSphere->GetOverlappingActors(CollectedActors);
    
    // For each actor we collected
    for (int32 iCollected = 0; iCollected < CollectedActors.Num(); ++iCollected)
    {
        // Cast the actor to APickup
        APickup* const TestPickup = Cast<APickup>(CollectedActors[iCollected]);
        
        // If the cast is successful and the pickup is valid and active
        if (TestPickup && IsValid(TestPickup) && TestPickup->IsActive())
        {
            // Call the pickup's WasCollected function
            TestPickup->WasCollected();
            
            // Deactivate the pickup
            TestPickup->SetActive(false);
        }
    }
}
```

### Setting Up Input

1. Create a new Input Action called **IA_Collect**
2. Open **IMC_Default** and add a mapping for **IA_Collect** with the **C** key
3. In **BatteryCollectorCharacter.h**, add:

```cpp
/** Collect Input Action */
UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = "true"))
class UInputAction* CollectAction;
```

4. In **BatteryCollectorCharacter.cpp**, bind the action:

```cpp
EnhancedInputComponent->BindAction(CollectAction, ETriggerEvent::Triggered, this, &ABatteryCollectorCharacter::CollectPickups);
```

5. Set **IA_Collect** as the **Collect Action** in **BP_ThirdPersonCharacter**

### Adding WasCollected Function to Pickup

In **Pickup.h**:

```cpp
/** Function to call when the pickup is collected */
UFUNCTION(BlueprintNativeEvent)
void WasCollected();
virtual void WasCollected_Implementation();
```

In **Pickup.cpp**:

```cpp
void APickup::WasCollected_Implementation()
{
    // Log a debug message
    FString PickupDebugString = GetName();
    UE_LOG(LogClass, Log, TEXT("You have collected %s"), *PickupDebugString);
}
```

## Adding Power to the Game

### Character Power System

Add to **BatteryCollectorCharacter.h**:

```cpp
protected:
    /** The starting power level of our character */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Power", Meta = (BlueprintProtected = "true"))
    float InitialPower;
    
    /** Multiplier for character speed */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Power", Meta = (BlueprintProtected = "true"))
    float SpeedFactor;
    
    /** Speed when power level = 0 */
    UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Power", Meta = (BlueprintProtected = "true"))
    float BaseSpeed;

private:
    /** Current power level of our character */
    UPROPERTY(VisibleAnywhere, Category = "Power")
    float CharacterPower;

public:
    /** Accessor function for initial power */
    UFUNCTION(BlueprintPure, Category = "Power")
    float GetInitialPower();
    
    /** Accessor function for current power */
    UFUNCTION(BlueprintPure, Category = "Power")
    float GetCurrentPower();
    
    /**
    Function to update the character's power 
    * @param PowerChange This is the amount to change the power by, and it can be positive or negative.
    */
    UFUNCTION(BlueprintCallable, Category = "Power")
    void UpdatePower(float PowerChange);

protected:
    UFUNCTION(BlueprintImplementableEvent, Category = "Power")
    void PowerChangeEffect();
```

### Character Power Implementation

In **BatteryCollectorCharacter.cpp** constructor:

```cpp
// Set a base power level for the character
InitialPower = 2000.f;
CharacterPower = InitialPower;

// Set the dependence of the speed on the power level
SpeedFactor = 0.75f;
BaseSpeed = 10.f;
```

Add the accessor and update functions:

```cpp
// Reports starting power
float ABatteryCollectorCharacter::GetInitialPower()
{
    return InitialPower;
}

// Reports current power
float ABatteryCollectorCharacter::GetCurrentPower()
{
    return CharacterPower;
}

// Called whenever power is increased or decreased
void ABatteryCollectorCharacter::UpdatePower(float PowerChange)
{
    // Change power
    CharacterPower = CharacterPower + PowerChange;
    
    // Change speed based on power
    GetCharacterMovement()->MaxWalkSpeed = BaseSpeed + SpeedFactor * CharacterPower;
    
    // Call visual effect
    PowerChangeEffect();
}
```

### Powering Up from Batteries

Update the **CollectPickups** function:

```cpp
void ABatteryCollectorCharacter::CollectPickups()
{
    // Get all overlapping Actors and store them in an array
    TArray<AActor*> CollectedActors;
    CollectionSphere->GetOverlappingActors(CollectedActors);
    
    // Keep track of the collected power
    float CollectedPower = 0;
    
    // For each actor we collected
    for (int32 iCollected = 0; iCollected < CollectedActors.Num(); ++iCollected)
    {
        // Cast the actor to APickup
        APickup* const TestPickup = Cast<APickup>(CollectedActors[iCollected]);
        
        // If the cast is successful and the pickup is valid and active
        if (TestPickup && IsValid(TestPickup) && TestPickup->IsActive())
        {
            // Call the pickup's WasCollected function
            TestPickup->WasCollected();
            
            // Check to see if the pickup is also a battery
            ABatteryPickup* const TestBattery = Cast<ABatteryPickup>(TestPickup);
            if (TestBattery)
            {
                // Increase the collected power
                CollectedPower += TestBattery->GetPower();
            }
            
            // Deactivate the pickup
            TestPickup->SetActive(false);
        }
    }
    
    if (CollectedPower > 0)
    {
        UpdatePower(CollectedPower);
    }
}
```

## GameMode Power Drain

### GameMode Power System

Add to **BatteryCollectorGameMode.h**:

```cpp
protected:
    /** The rate at which the character loses power */
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Power", Meta = (BlueprintProtected = true))
    float DecayRate;
    
    /** The power needed to win the game */
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Power", Meta = (BlueprintProtected = true))
    float PowerToWin;

public:
    virtual void Tick(float DeltaTime) override;
    virtual void BeginPlay() override;
    
    /** Returns the power needed to win - needed for the HUD */
    UFUNCTION(BlueprintPure, Category = "Power")
    float GetPowerToWin() const;
```

### GameMode Implementation

In **BatteryCollectorGameMode.cpp** constructor:

```cpp
// Base decay rate
DecayRate = 0.01f;

PrimaryActorTick.bCanEverTick = true;
```

Add the implementation:

```cpp
#include <Kismet/GameplayStatics.h>

void ABatteryCollectorGameMode::BeginPlay()
{
    Super::BeginPlay();
    
    // Set score to beat
    ABatteryCollectorCharacter* MyCharacter = Cast<ABatteryCollectorCharacter>(UGameplayStatics::GetPlayerPawn(this, 0));
    if (MyCharacter)
    {
        PowerToWin = (MyCharacter->GetInitialPower()) * 1.25f;
    }
}

void ABatteryCollectorGameMode::Tick(float DeltaTime)
{
    Super::Tick(DeltaTime);
    
    // Check that we are using the battery collector character 
    ABatteryCollectorCharacter* MyCharacter = Cast<ABatteryCollectorCharacter>(UGameplayStatics::GetPlayerPawn(this, 0));
    if (MyCharacter)
    {
        // If the character's power is positive
        if (MyCharacter->GetCurrentPower() > 0)
        {
            // Decrease the character's power using the decay rate
            MyCharacter->UpdatePower(-DeltaTime * DecayRate * (MyCharacter->GetInitialPower()));
        }
    }
}

float ABatteryCollectorGameMode::GetPowerToWin() const
{
    return PowerToWin;
}
```

## Character Visual Effects

### Material Color Changes

In **BP_ThirdPersonCharacter**, set up the **PowerChangeEffect** Blueprint event:

1. Create a **Dynamic Material Instance** in the Construction Script
2. In the Event Graph, create an **Event PowerChangeEffect**
3. Set up a **Lerp** between two colors based on Current Power / Initial Power ratio
4. Use **Set Vector Parameter Value** to change the material tint

### Speed Changes

The speed changes are already implemented in the **UpdatePower** function in C++, where **MaxWalkSpeed** is updated based on the character's power level.

## Creating Particle Effects

### Electric Arc Material

1. Create a new **Material** called **M_ElectricArc**
2. Set **Shading Model** to **Unlit**
3. Connect **Particle Color** to **Emissive Color**

### Niagara Particle System

1. Create a new **Niagara System** called **P_ElectricArcs**
2. Use **Static Beam** emitter
3. Set up **BeamEnd** as a user-exposed parameter
4. Configure material and beam properties

### Adding Particles to Battery

In **Battery_BP**, add the particle effect to the **WasCollected** event:

1. **Spawn System Attached** with **P_ElectricArcs**
2. Get the player character's socket location
3. Set the **BeamEnd** parameter to target the character
4. Add delay and parent function call

## HUD System

### Enabling UMG

Add to **BatteryCollector.Build.cs**:

```cs
PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", "UMG"});

PrivateDependencyModuleNames.AddRange(new string[] { "Slate", "SlateCore" });
```

### GameMode HUD Setup

Add to **BatteryCollectorGameMode.h**:

```cpp
#include <UserWidget.h>

protected:
    /** The Widget class to use for our HUD screen */
    UPROPERTY(EditDefaultsOnly, BlueprintReadWrite, Category = "Power", Meta = (BlueprintProtected = true))
    TSubclassOf<class UUserWidget> HUDWidgetClass;
    
    /** The instance of the HUD */
    UPROPERTY()
    class UUserWidget* CurrentWidget;
```

In **BeginPlay**, add:

```cpp
if (HUDWidgetClass != nullptr)
{
    CurrentWidget = CreateWidget<UUserWidget>(GetWorld(), HUDWidgetClass);
    if (CurrentWidget != nullptr)
    {
        CurrentWidget->AddToViewport();
    }
}
```

### HUD Blueprint

Create **BatteryHUD** Widget Blueprint with:

1. **Progress Bar** for power level
2. **Text Block** for game state messages
3. Bind progress bar to **Current Power / Power To Win**
4. Bind text to game state messages

## Game States

### Play State Enum

Add to **BatteryCollectorGameMode.h**:

```cpp
// Enum to store the current state of gameplay
UENUM(BlueprintType)
enum class EBatteryPlayState : uint8
{
    EPlaying,
    EGameOver,
    EWon,
    EUnknown
};

private:
    /** Keeps track of the current playing state */
    EBatteryPlayState CurrentState;
    
    TArray<class ASpawnVolume*> SpawnVolumeActors;
    
    /** Handle any function calls that rely upon changing the playing state of our game */
    void HandleNewState(EBatteryPlayState NewState);

public:
    /** Returns the current playing state */
    UFUNCTION(BlueprintPure, Category = "Power")
    EBatteryPlayState GetCurrentState() const;
    
    /** Sets a new playing state */
    void SetCurrentState(EBatteryPlayState NewState);
```

### State Management Implementation

```cpp
#include "SpawnVolume.h"

void ABatteryCollectorGameMode::BeginPlay()
{
    Super::BeginPlay();
    
    // Find all spawn volume Actors
    TArray<AActor*> FoundActors;
    UGameplayStatics::GetAllActorsOfClass(GetWorld(), ASpawnVolume::StaticClass(), FoundActors);
    
    for (auto Actor : FoundActors)
    {
        ASpawnVolume* SpawnVolumeActor = Cast<ASpawnVolume>(Actor);
        if (SpawnVolumeActor)
        {
            SpawnVolumeActors.AddUnique(SpawnVolumeActor);
        }
    }
    
    SetCurrentState(EBatteryPlayState::EPlaying);
    
    // Set score to beat
    ABatteryCollectorCharacter* MyCharacter = Cast<ABatteryCollectorCharacter>(UGameplayStatics::GetPlayerPawn(this, 0));
    if (MyCharacter)
    {
        PowerToWin = (MyCharacter->GetInitialPower()) * 1.25f;
    }
    
    if (HUDWidgetClass != nullptr)
    {
        CurrentWidget = CreateWidget<UUserWidget>(GetWorld(), HUDWidgetClass);
        if (CurrentWidget != nullptr)
        {
            CurrentWidget->AddToViewport();
        }
    }
}

EBatteryPlayState ABatteryCollectorGameMode::GetCurrentState() const
{
    return CurrentState;
}

void ABatteryCollectorGameMode::SetCurrentState(EBatteryPlayState NewState)
{
    // Set current state
    CurrentState = NewState;
    // Handle the new current state
    HandleNewState(CurrentState);
}

void ABatteryCollectorGameMode::HandleNewState(EBatteryPlayState NewState)
{
    switch (NewState)
    {
        // If the game is playing
        case EBatteryPlayState::EPlaying:
        {
            // Spawn volumes active
            for (ASpawnVolume* Volume : SpawnVolumeActors)
            {
                Volume->SetSpawningActive(true);
            }
        }
        break;
        
        // If we've won the game 
        case EBatteryPlayState::EWon:
        {
            // Spawn volumes inactive
            for (ASpawnVolume* Volume : SpawnVolumeActors)
            {
                Volume->SetSpawningActive(false);
            }
        }
        break;
        
        // If we've lost the game
        case EBatteryPlayState::EGameOver:
        {
            // Spawn volumes inactive
            for (ASpawnVolume* Volume : SpawnVolumeActors)
            {
                Volume->SetSpawningActive(false);
            }
            
            // Block player input
            APlayerController* PlayerController = UGameplayStatics::GetPlayerController(this, 0);
            if (PlayerController)
            {
                PlayerController->SetCinematicMode(true, false, false, true, true);
            }
            
            // Ragdoll the character
            ACharacter* MyCharacter = UGameplayStatics::GetPlayerCharacter(this, 0);
            if (MyCharacter)
            {
                MyCharacter->GetMesh()->SetSimulatePhysics(true);
                MyCharacter->GetMovementComponent()->MovementState.bCanJump = false;
            }
        }
        break;
        
        // Unknown/default state
        default:
        case EBatteryPlayState::EUnknown:
        {
            // Do nothing
        }
        break;
    }
}
    